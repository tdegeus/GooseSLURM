#!/usr/bin/env python3
'''Ginfo
  Summarize the status of all or a selection of jobs (wrapper around sinfo).

  Some scores per node are computed:

  * CPU% : the CPU load of the node, relative to the total number of CPUs in the node.
           cpu_load / cpu_tot
           should be <1

  * CPU# : the CPU load of the node, relative to the number of jobs.
           cpu_load / cpu_used
           should be ~1

  * Mem% : the amount of used memory, relative to the total amount of memory in the node.
           mem_used / mem_tot
           should be <1

  * Mem# : the amount of used memory, relative to the average memory available per job.
           ( mem_used / cpu_used ) / ( mem_tot / cpu_tot )
           is >1 for (several) heavy memory consumption jobs
Usage:
  Ginfo [options]
  Ginfo [options] [--sort=N...] [--job=N...] [--free=N...]

Options:
  -n, --node=<NAME>       Limit jobs to a certain node (may be a regex).
  -f, --free=<NAME>       Limit jobs to a certain free CPUs (may be a regex).
  -p, --partition=<NAME>  Limit jobs to a certain partition (may be a regex).
  -s, --sort=<NAME>       Sort by field (selected by the header-name).
  -r, --reverse           Reverse sort [default: False].
      --output=<NAME>     Select output columns.
      --no-header         Suppress header, for easy parsing.
      --sep=<NAME>        Column separator. [default:  ] (space)
      --long              Print all information.
      --debug=<FILE>      Debug with output 'sinfo -o "%all"' provided from file.
  -h, --help              Show help.
      --version           Show version.

Copyright:
  T.W.J. de Geus
  tom@geus.me
  www.geus.me
'''

# ========================================= LOAD LIBRARIES =========================================

import subprocess, shutil, docopt, pwd, os, sys, time, re

# ================================== CLASS TO REPRESENT A NUMBER ===================================

class Number:
  r'''
Class to represent a number.

This class can also deal with non-numeric input, it allows to input e.g. "N/A".
  '''

  # ------------------------------------------- __init__ -------------------------------------------

  def __init__(self,data):

    self.data = data

  # ------------------------------------------- __int__ --------------------------------------------

  def __int__(self):

    if type(self.data) == int  : return     self.data
    if type(self.data) == float: return int(self.data)

    return 0

  # ------------------------------------------ __float__ -------------------------------------------

  def __float__(self):

    if type(self.data) == float: return       self.data
    if type(self.data) == int  : return float(self.data)

    return 0.0

  # ------------------------------------------- isnum() --------------------------------------------

  def isnum(self):

    if type(self.data) == float: return True
    if type(self.data) == int  : return True

    return False

  # -------------------------------------------- __lt__ --------------------------------------------

  def __lt__(self,other):

    if isinstance(other,Number):

      if type(self.data)  == str and type(other.data) == str: return self.data < other.data
      if type(self.data)  == str: return -1
      if type(other.data) == str: return  0

      return float(self) < float(other)

    if type(self.data) == str: return -1

    return float(self) < float(other)

  # ------------------------------------------ __format__ ------------------------------------------

  def __format__(self,fmt):

    return ('{0:'+fmt+'}').format(str(self))

  # ------------------------------------------- __len__ --------------------------------------------

  def __len__(self):

    return len(str(self))

  # ------------------------------------------- __repr__ -------------------------------------------

  def __repr__(self):

    return self.__str__()

  # ------------------------------------------- __str__ --------------------------------------------

  def __str__(self):

    if type(self.data) == str: return self.data

    return str(self.data)

# ======================== CHILD-CLASS TO REPRESENT A DURATION IN SECTIONS =========================

class Duration(Number):
  r'''
Class to represent a duration in seconds as e.g. "3h".

Any non-numeric value will be kept as-is, through the parent-class "Number".
  '''

  # ------------------------------------------- __str__ --------------------------------------------

  def __str__(self):

    if type(self.data) == str: return self.data

    secs = [60*60*24, 60*60, 60, 1]
    name = ['d', 'h', 'm', 's']

    for i,txt in zip(secs,name):
      if abs(self.data) >= i:
        n = float(self.data)/float(i)
        if abs(round(n)) < 10.: return '%.1f%s'%(      n ,txt)
        else                  : return '%.0f%s'%(round(n),txt)

    return '%.0fs'%float(self.data)

# =========================== CHILD-CLASS TO REPRESENT A MEMORY IN BYTES ===========================

class Memory(Number):
  r'''
Class to represent memory in bytes as e.g. "4G"

Any non-numeric value will be kept as-is, through the parent-class "Number".
  '''

  # ------------------------------------------- __str__ --------------------------------------------

  def __str__(self):

    if type(self.data) == str: return self.data

    byte = [1e12, 1e9, 1e6, 1e3, 1]
    name = ['T', 'G', 'M', 'K', 'B']

    for i,txt in zip(byte,name):
      if abs(self.data) >= i:
        n = float(self.data)/float(i)
        return '%.0f%s'%(round(n),txt)

    return '-'

# ============================= CHILD-CLASS TO REPRESENT A PERCENTAGE ==============================

class Percentage(Number):
  r'''
Class to represent a percentage, with precision 2.

Any non-numeric value will be kept as-is, through the parent-class "Number".
  '''

  # ------------------------------------------- __str__ --------------------------------------------

  def __str__(self):

    if type(self.data) == str: return self.data

    return '%4.2f' % self.data

# ====================== SUPPORT FUNCTION: CHECK THAT ALL FIELDS ARE NUMERIC =======================

def isnum(job,keys):

  for key in keys:
    if not job[key].isnum():
      return False

  return True

# ========================================== MAIN PROGRAM ==========================================

# --------------------------- support function: raise command line error ---------------------------

def Error(msg,exit_code=1):
  print(msg)
  sys.exit(exit_code)

# --------------------------------- parse command line interaction ---------------------------------

# parse command-line options
args = docopt.docopt(__doc__,version='0.0.2')

# rename fields
args['HOSTNAMES'] = args.pop('--job'      )
args['CPUS_I'   ] = args.pop('--free'     )
args['PARTITION'] = args.pop('--partition')

# default headers -> custom headers
alias = {
  'HOSTNAMES'  :'Host',
  'CPUS_T'     :'Ctot',
  'CPUS_I'     :'Cfree',
  'CPU_REL'    :'CPU%',
  'PARTITION'  :'Partition',
  'MEMORY'     :'Mem',
  'MEM_REL'    :'Mem%',
  'MEM_RELJOB' :'Mem#',
  'TIMELIMIT'  :'Tlim',
  'STATE'      :'State',
  'CPU_LOAD'   :'Load',
  'CPU_RELJOB' :'CPU#'
}

# custom headers -> default headers
aliasInv = {alias[key].upper():key for key in alias}

# print settings: width == minimum width, real == real width (computed below)
fields = [
  {'key':'HOSTNAMES' ,'width':5 ,'real':0,'align':'<'},
  {'key':'CPUS_T'    ,'width':5 ,'real':0,'align':'>'},
  {'key':'CPUS_I'    ,'width':5 ,'real':0,'align':'>'},
  {'key':'CPU_REL'   ,'width':5 ,'real':0,'align':'>'},
  {'key':'CPU_RELJOB','width':5 ,'real':0,'align':'>'},
  {'key':'MEMORY'    ,'width':3 ,'real':0,'align':'>'},
  {'key':'MEM_REL'   ,'width':5 ,'real':0,'align':'>'},
  {'key':'MEM_RELJOB','width':5 ,'real':0,'align':'>'},
  {'key':'PARTITION' ,'width':9 ,'real':0,'align':'<'},
  {'key':'TIMELIMIT' ,'width':5 ,'real':0,'align':'>'},
  {'key':'STATE'     ,'width':5 ,'real':0,'align':'<'},
]

# ----------------------------------- load the output of "sinfo" -----------------------------------

# get live job-info, or mimic live behavior by reading file
if not args['--debug']:
  cmd  = 'sinfo -o "%all"'
  data = subprocess.check_output(cmd,shell=True).decode('utf-8')
else:
  data = open(args['--debug'],'r').read()
  now  = os.path.getctime(args['--debug'])

# extract the header and the info
header,data = data.split('\n',1)
data        = list(filter(None,data.split('\n')))

# get the field names
header = header.split('|')

# convert to list of dictionaries
# - initialize
jobs = []
# - loop over jobs
for job in data:
  # -- initialize empty dictionary
  info = {}
  # -- fill dictionary
  for key,val in zip(header,job.split('|')):
    if len(key.strip()) > 0:
      info[key.strip()] = val.strip()
  # -- store to list of jobs
  jobs += [info]

# ------------------------------ limit based on command-line options -------------------------------

for key in ['HOSTNAMES','PARTITION']:
  if args[key]:
    jobs = [job for job in jobs if sum([1 if re.match(name,str(job[key])) else 0 for name in args[key]])]

# -------------------------------- convert type of relevant fields ---------------------------------

# loop over all jobs
for job in jobs:

  # CPUs: allocated/idle/other/total
  job['CPUS_A'], job['CPUS_I'], job['CPUS_O'], job['CPUS_T'] = job['CPUS(A/I/O/T)'].split('/')

  # convert to numbers
  for key in ['CPUS_A', 'CPUS_I', 'CPUS_O', 'CPUS_T']:
    job[key] = Number(int(job[key]))

  # convert to numbers
  for key in ['CPU_LOAD']:
    if not re.match('.*[0-9].*',job[key]): job[key] = Number(job[key])
    else                                  : job[key] = Number(float(job[key]))

  # convert e.g. "1-4:18:13" -> seconds
  for key in ['TIMELIMIT']:
    # - initialize alias + data [days,hours,minutes,seconds]
    txt = job[key]
    dt  = [0,0,0,0]
    # - read number of days
    if len(job[key].split('-')) > 1: dt[0],txt = job[key].split('-')
    # - split hours:minutes:seconds (all optional)
    txt = txt.split(':')
    # - fill from seconds -> minutes (if present) -> hours (if present)
    for i in range(len(txt)): dt[-1*(i+1)] = txt[-1*(i+1)]
    # - store in seconds
    try   : job[key] = Duration(int(dt[0])*24*60*60 + int(dt[1])*60*60 + int(dt[2])*60 + int(dt[3]))
    except: job[key] = Duration(job[key])

  # convert to memory
  for key, byte in zip(['MEMORY','FREE_MEM'], [1.e6,1.e6]):
    # - read value and units
    if not re.match('.*[0-9].*',job[key]):
      job[key] = Memory(job[key])
      continue
    if re.match('[0-9\.]*[A-Za-z]',job[key]):
      val  = float(job[key][:-1])
      unit =       job[key][ -1]
    else:
      val  = float(job[key])
      unit = ''
    # - convert to bytes
    if   unit == 'K': unit = byte * 1.e3
    elif unit == 'M': unit = byte * 1.e6
    elif unit == 'G': unit = byte * 1.e9
    elif unit == 'T': unit = byte * 1.e12
    else            : unit = byte * 1.
    # - store
    job[key] = Memory(val*unit)

  # compute memory and CPU scores
  # - initialize
  job['MEM_REL'   ] = Percentage('')
  job['MEM_RELJOB'] = Percentage('')
  job['CPU_REL'   ] = Percentage('')
  job['CPU_RELJOB'] = Percentage('')
  # - memory usage, relative to the total memory in the node
  if isnum(job,['FREE_MEM','MEMORY']):
    # -- extract parameters
    mem_used = float(job['MEMORY'])-float(job['FREE_MEM'])
    mem_tot  = float(job['MEMORY'])
    # -- compute
    if mem_tot > 0:
      job['MEM_REL'] = Percentage(mem_used/mem_tot)
  # - memory usage, relative to the average available memory per job
  if isnum(job,['FREE_MEM','MEMORY','CPUS_A','CPUS_T']):
    # -- extract parameters
    mem_used = float(job['MEMORY'])-float(job['FREE_MEM'])
    mem_tot  = float(job['MEMORY'])
    cpu_used = float(job['CPUS_A'])
    cpu_tot  = float(job['CPUS_T'])
    # -- compute
    if mem_tot > 0 and cpu_used > 0:
      job['MEM_RELJOB'] = Percentage(mem_used/mem_tot * cpu_tot/cpu_used)
  # - CPU load, relative to the total number of CPUs in the node
  if isnum(job,['CPU_LOAD','CPUS_T']):
    # -- extract parameters
    cpu_load = float(job['CPU_LOAD'])
    cpu_tot  = float(job['CPUS_T'])
    # -- compute
    if cpu_tot > 0:
      job['CPU_REL'] = Percentage(cpu_load/cpu_tot)
  # - CPU load, relative to the average available load per job
  if isnum(job,['CPU_LOAD','CPUS_A']):
    # -- extract parameters
    cpu_load = float(job['CPU_LOAD'])
    cpu_used = float(job['CPUS_A'])
    # -- compute
    if cpu_used > 0:
      job['CPU_RELJOB'] = Percentage(cpu_load/cpu_used)

# ---------------------------------------------- sort ----------------------------------------------

if args['--sort']:
  for key in args['--sort']:
    jobs = sorted(jobs, key=lambda job: job[aliasInv[key.upper()]], reverse=args['--reverse'])
else:
  jobs = sorted(jobs, key=lambda job: job[aliasInv['HOST']],      reverse=args['--reverse'])
  jobs = sorted(jobs, key=lambda job: job[aliasInv['PARTITION']], reverse=args['--reverse'])

# ---------------------------- option: print long information and quit -----------------------------

if args['--long']:

  fmt = 0

  for job in jobs:
    for key in sorted(job):
      fmt = max(fmt,len(key))

  head = '{key:<%d.%ss}'           % (fmt+1,fmt+1)
  fmt  = '{key:<%d.%ss}: {data:s}' % (fmt+1,fmt+1)

  print(head.format(key='-'*100,data=''))

  for job in jobs:
    for key in sorted(job):
      print(fmt.format(key=key,data=str(job[key])))
    print(head.format(key='-'*100,data=''))

  sys.exit(0)

# ------------------- support function: convert column settings to print format --------------------

def field2fmt(key,width,align,color=None,header=False,**kwargs):

  if header: fmt = '{%s:%s%d.%ds}'%(key,'<',width,width)
  else     : fmt = '{%s:%s%d.%ds}'%(key,align,width,width)

  if color: fmt = '\x1b[%sm'%color+fmt+'\x1b[0m'

  return fmt

# --------------------------------- create print format and print ----------------------------------

# adjust fields and their width
# -----------------------------

if not args['--output']:

  # add color for selection
  for field in fields:
    if field['key'] in args:
      if args[field['key']]:
        field['color'] = '1;32;40'

  # get the terminal size
  cols,_ = shutil.get_terminal_size()

  # get the cumulative minimum size of the columns (+ spacing between the columns)
  if True:                       fields[0]['total'] = fields[0  ]['width']
  for i in range(1,len(fields)): fields[i]['total'] = fields[i-1]['total'] + fields[i]['width'] + 1

  # truncate at terminal size
  fields = [field for field in fields if field['total'] <= cols]

  # get actual width
  for job in jobs:
    for field in fields:
      field['real'] = max(field['real'],len(job[field['key']]))

  # get the available size to expand
  room = cols - fields[-1]['total']

  # expand minimum width, as long there is room
  # - distinguish priorities for expanding
  low  = ['NAME']
  high = [field['key'] for field in fields if field['key'] not in low]
  # - expand
  for prio in [high,low]:
    for field in fields:
      if field['key'] not in prio: continue
      if room <= 0: break
      dw = min(field['real']-field['width'],room)
      if dw <= 0: continue
      field['width'] += dw
      room           -= dw

# fixed output
# ------------

if args['--output']:

  # avoid case conflicts
  output = [name.upper() for name in args['--output']]

  # select fields
  fields = [field for field in fields if field['key'] in output]

  # get actual width
  for job in jobs:
    for field in fields:
      field['real'] = max(field['real'],len(job[field['key']]))

  # set width
  for field in fields:
    field['width'] = field['real']

# print result to screen
# ----------------------

# convert to print format
head = args['--sep'].join([field2fmt(**field,header=True ) for field in fields])
fmt  = args['--sep'].join([field2fmt(**field,header=False) for field in fields])

# print to screen
# ---------------

# header
if not args['--no-header']:
  print(head.format(**{field['key']:alias[field['key' ]] for field in fields}))
  print(head.format(**{field['key']:'='*  field['width'] for field in fields}))

# jobs
for job in jobs:
  print(fmt.format(**job))
