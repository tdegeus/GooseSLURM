#!/usr/bin/env python3
'''Gscript

  Automatically generate job-scripts with logical job-names set. The generated scripts must be
  submitted using "sbatch NAME" from the folder in which they are written. This can be automized
  using the "Gsub" command.

Usage:
  Gscript [options] [--sbatch=<TEXT>...] <INPUT>...

Arguments:
  <INPUT>...                Input files, or simulations folders. In the case of input files, its
                            name is written to the command using ("cmd % inputfile"). In the case
                            of folders the commands is used as is.

Options:
      --type=<TEXT>         The type of script: tempdir, scratch, or local. [default: tempdir]
      --cmd=<TEXT>          The command(s) to execute. [default: ]
      --extension=<TEXT>    Extension of the job-script. [default: .slurm]
      --filename=<TEXT>     Filename of the job-script (ignored for input-files). [default: job]
  -J, --job-name=<TEXT>     Set the job-name. (default: relative path)
  -c, --cpus-per-task=<N>   Number of CPUs-per-task. [default: 1]
  -t, --time=<TEXT>         Specify the maximum walltime. [default: 1d]
  -m, --mem=<N>             Specify the maximum memory usage in MB. [default: 1028]
  -A, --account=<TEXT>      Specify account name. (default: )
      --sbatch<TEXT>        Miscellaneous SBATCH options.
  -h, --help                Show help.
      --version             Show version.

Copyright:
  T.W.J. de Geus
  tom@geus.me
  www.geus.me
'''

# ==================================================================================================

tempdir = '''#!/bin/bash
{slurm:s}

# 1. Generate unique directory name [DO NOT CHANGE]
# =================================================

# get name of the temporary directory working directory, physically on the compute-node
workdir="$TMPDIR"

# store submit directory
# (every file/folder below this directory is copied to the compute-node)
submitdir="${{SLURM_SUBMIT_DIR}}"

# 2. Write job-info to a log-file [MAY BE CHANDED/OMITTED]
# ========================================================

cat <<EOF > {name:s}.json
{{
  "workdir"             : "${{workdir}}",
  "submitdir"           : "${{submitdir}}",
  "SLURM_SUBMIT_DIR"    : "${{SLURM_SUBMIT_DIR}}",
  "SLURM_JOB_ID"        : "${{SLURM_JOB_ID}}",
  "SLURM_JOB_NODELIST"  : "${{SLURM_JOB_NODELIST}}",
  "SLURM_SUBMIT_HOST"   : "${{SLURM_SUBMIT_HOST}}",
  "SLURM_JOB_NUM_NODES" : "${{SLURM_JOB_NUM_NODES}}",
  "SLURM_CPUS_PER_TASK" : "${{SLURM_CPUS_PER_TASK}}"
}}
EOF

# 3. Transfer to node [DO NOT CHANGE]
# ===================================

# create/empty the temporary directory on the compute-node
if [ ! -d "${{workdir}}" ]; then
  mkdir -p "${{workdir}}"
else
  rm -rf "${{workdir}}"/*
fi

# change current directory to the location of the sbatch-command
# ("submitdir" is somewhere in the home directory on the head-node)
cd "${{submitdir}}"
# copy all files/folders in "submitdir" to "workdir"
# ("workdir" == temporary directory on the compute-node)
cp -prf * ${{workdir}}
# change directory to the temporary directory on the compute-node
cd ${{workdir}}

# 4. Function to transfer back to the head-node [DO NOT CHANGE]
# =============================================================

# define clean-up function
function clean_up {{
  # - change directory to the location of the sbatch-command (on the head-node)
  cd "${{submitdir}}"
  # - copy everything from the temporary directory on the compute-node
  cp -prf "${{workdir}}"/* .
  # - erase the temporary directory from the compute-node
  rm -rf "${{workdir}}"/*
  rm -rf "${{workdir}}"
  # - exit the script
  exit
}}

# call "clean_up" function when this script exits, it is run even if SLURM cancels the job
trap 'clean_up' EXIT

# 5. Execute [MODIFY COMPLETELY TO YOUR NEED]
# ===========================================

# set the number of CPUs to be used by an OpenMP application
export OMP_NUM_THREADS=${{SLURM_CPUS_PER_TASK}}

{command:s}
'''

# --------------------------------------------------------------------------------------------------

scratch = '''#!/bin/bash
{slurm:s}

# 1. Generate unique directory name [DO NOT CHANGE]
# =================================================

# store my username
username=`whoami`

# get name of the temporary directory working directory in the scratch folder
# use job-id to create a unique folder
workdir="/scratch/$username/${{SLURM_JOB_ID}}"

# store submit directory
# (every file/folder below this directory is copied to the compute-node)
submitdir="${{SLURM_SUBMIT_DIR}}"

# 2. Write job-info to a log-file [MAY BE CHANDED/OMITTED]
# ========================================================

cat <<EOF > {name:s}.json
{{
  "workdir"             : "${{workdir}}",
  "submitdir"           : "${{submitdir}}",
  "SLURM_SUBMIT_DIR"    : "${{SLURM_SUBMIT_DIR}}",
  "SLURM_JOB_ID"        : "${{SLURM_JOB_ID}}",
  "SLURM_JOB_NODELIST"  : "${{SLURM_JOB_NODELIST}}",
  "SLURM_SUBMIT_HOST"   : "${{SLURM_SUBMIT_HOST}}",
  "SLURM_JOB_NUM_NODES" : "${{SLURM_JOB_NUM_NODES}}",
  "SLURM_CPUS_PER_TASK" : "${{SLURM_CPUS_PER_TASK}}"
}}
EOF

# 3. Transfer to node [DO NOT CHANGE]
# ===================================

# create/empty the temporary directory on the compute-node
if [ ! -d "${{workdir}}" ]; then
  mkdir -p "${{workdir}}"
else
  rm -rf "${{workdir}}"/*
fi

# change current directory to the location of the sbatch-command
# ("submitdir" is somewhere in the home directory on the head-node)
cd "${{submitdir}}"
# copy all files/folders in "submitdir" to "workdir"
# ("workdir" == temporary directory on the compute-node)
cp -prf * ${{workdir}}
# change directory to the temporary directory on the compute-node
cd ${{workdir}}

# 4. Function to transfer back to the head-node [DO NOT CHANGE]
# =============================================================

# define clean-up function
function clean_up {{
  # - change directory to the location of the sbatch-command (on the head-node)
  cd "${{submitdir}}"
  # - copy everything from the temporary directory on the compute-node
  cp -prf "${{workdir}}"/* .
  # - erase the temporary directory from the compute-node
  rm -rf "${{workdir}}"/*
  rm -rf "${{workdir}}"
  # - exit the script
  exit
}}

# call "clean_up" function when this script exits, it is run even if SLURM cancels the job
trap 'clean_up' EXIT

# 5. Execute [MODIFY COMPLETELY TO YOUR NEED]
# ===========================================

# set the number of CPUs to be used by an OpenMP application
export OMP_NUM_THREADS=${{SLURM_CPUS_PER_TASK}}

{command:s}
'''

# --------------------------------------------------------------------------------------------------

local = '''#!/bin/bash
{slurm:s}

# 1. Write job-info to a log-file [MAY BE CHANDED/OMITTED]
# ========================================================

cat <<EOF > {name:s}.json
{{
  "workdir"             : "${{workdir}}",
  "submitdir"           : "${{submitdir}}",
  "SLURM_SUBMIT_DIR"    : "${{SLURM_SUBMIT_DIR}}",
  "SLURM_JOB_ID"        : "${{SLURM_JOB_ID}}",
  "SLURM_JOB_NODELIST"  : "${{SLURM_JOB_NODELIST}}",
  "SLURM_SUBMIT_HOST"   : "${{SLURM_SUBMIT_HOST}}",
  "SLURM_JOB_NUM_NODES" : "${{SLURM_JOB_NUM_NODES}}",
  "SLURM_CPUS_PER_TASK" : "${{SLURM_CPUS_PER_TASK}}"
}}
EOF

# 2. Execute [MODIFY COMPLETELY TO YOUR NEED]
# ===========================================

# set the number of CPUs to be used by an OpenMP application
export OMP_NUM_THREADS=${{SLURM_CPUS_PER_TASK}}

{command:s}
'''

# ==================================================================================================

import docopt, os, sys, re, time

# parse command-line options
# --------------------------

# function to raise error
def Error(txt):
  print(txt)
  sys.exit(1)

# parse command-line options
args = docopt.docopt(__doc__,version='0.0.3')

# evaluate new-line characters
args['--cmd'] = args['--cmd'].replace('\\n','\n')

# convert human readable time format
if not re.match('[0-9]*\:[0-9]*\:[0-9]*',args['--time']):
  # - alias
  T = args['--time']
  # - convert input to seconds
  if   T[-1] == 'd': T = float(T[:-1]) * float(60*60*24)
  elif T[-1] == 'h': T = float(T[:-1]) * float(60*60)
  elif T[-1] == 'm': T = float(T[:-1]) * float(60)
  elif T[-1] == 's': T = float(T[:-1]) * float(1)
  else             : T = float(T)
  # - convert seconds back to hours:minutes:seconds
  T = int(T)
  s = int( T % 60 );  T = ( T - s ) / 60
  m = int( T % 60 );  T = ( T - m ) / 60
  h = int( T )
  T = '%d:%02d:%02d' % (h,m,s)
  # - alias
  args['--time'] = T

# convert input
# -------------

# allocate
jobnames  = []
filenames = []
paths     = []
commands  = []
options   = []

# loop over arguments
for inp in args.pop('<INPUT>'):

  # input is file -> add filename to the command
  if os.path.isfile(inp):

    jobname  = inp
    filename = os.path.splitext(os.path.split(inp)[1])[0] + args['--extension']
    path     = os.path.split(inp)[0]

    try   : command = args['--cmd'] % os.path.split(inp)[1]
    except: command = args['--cmd'] + os.path.split(inp)[1]

  # input is directory -> use command as is
  else:

    jobname  = inp
    filename = args['--filename'] + args['--extension']
    path     = inp
    command  = args['--cmd']

  # set options
  option  = [ ]
  option += [ '#SBATCH --job-name %s' % jobname ]
  option += [ '#SBATCH --out %s.out' % filename ]
  option += [ '#SBATCH --error %s.error' % filename ]
  option += [ '#SBATCH --nodes 1' ]
  option += [ '#SBATCH --ntasks 1' ]
  option += [ '#SBATCH --cpus-per-task %s' % args['--cpus-per-task'] ]
  option += [ '#SBATCH --mem %s' % args['--mem'] ]
  option += [ '#SBATCH --time %s' % args['--time']]

  if args['--account']: option += [ '#SBATCH --account %s' % args['--account'] ]

  if args['--sbatch']:
    for opt in args['--sbatch']:
      option += ['#SBATCH %s' % opt]

  option  = '\n'.join(option)

  # store to list
  jobnames  += [ jobname  ]
  filenames += [ filename ]
  paths     += [ path     ]
  commands  += [ command  ]
  options   += [ option   ]

# write scripts
for jobname, filename, path, command, option in zip(jobnames, filenames, paths, commands, options):

  if   args['--type'] == 'tempdir': text = tempdir
  elif args['--type'] == 'scratch': text = scratch
  elif args['--type'] == 'local'  : text = local

  open(os.path.join(path,filename),'w').write(text.format(
    slurm   = option,
    name    = filename,
    command = command,
  ))

  print('Written "%s"' % os.path.join(path,filename))
