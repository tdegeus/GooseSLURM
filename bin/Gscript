#!/usr/bin/env python3
'''Gscript

  Automatically generate job-scripts with logical job-names set. The generated scripts must be
  submitted using "sbatch NAME" from the folder in which they are written. This can be automized
  using the "Gsub" command.

Usage:
  Gscript [options] [--sbatch=<TEXT>...] [--rm=<NAME>...] <INPUT>...

Arguments:
  Input files, or simulations folders:

  * Input files: <INPUT> is written to the command using ("cmd % <INPUT>").
  * Simulation folders: command is used as is.

Options:
      --type=<TEXT>         The type of script: tempdir, scratch, or local.   [default: tempdir]
      --cmd=<TEXT>          The command(s) to execute.
      --exec=<FILE>         Read the command(s) to execute from a file.
      --rm=<NAME>           File to remove before copying back to the submitdir.
      --extension=<TEXT>    Extension of the job-script.                      [default: .slurm]
      --filename=<TEXT>     Filename of the job-script (not for inputfile).   [default: job]
  -J, --job-name=<TEXT>     Job-name.                                         (default: path)
  -c, --cpus-per-task=<N>   Number of CPUs-per-task.                          [default: 1]
  -t, --time=<TEXT>         Maximum walltime     (use "false" to ignore).     [default: 1d]
  -m, --mem=<N>             Maximum memory in MB (use "false" to ignore).     [default: 1028]
  -A, --account=<TEXT>      Account name.
  -p, --partition=<TEXT>    Partition name.
      --sbatch<TEXT>        Miscellaneous SBATCH options.
  -h, --help                Show help.
      --version             Show version.

(c - MIT) T.W.J. de Geus | tom@geus.me | www.geus.me | github.com/tdegeus/GooseSLURM
'''

# ======================================== SCRIPT TEMPLATES ========================================

# ------------------------ temporary working directory on the compute-node -------------------------

tempdir = '''#!/bin/bash
{slurm:s}

# 1. Generate unique directory name [DO NOT CHANGE]
# =================================================

# get hostname
myhost=`hostname`

# get name of the temporary directory working directory, physically on the compute-node
workdir="$TMPDIR"

# get submit directory
# (every file/folder below this directory is copied to the compute-node)
submitdir="${{SLURM_SUBMIT_DIR}}"

# 2. Write job-info to a log-file [MAY BE CHANDED/OMITTED]
# ========================================================

cat <<EOF > {name:s}.json
{{
  "submitdir"           : "${{submitdir}}",
  "workdir"             : "${{workdir}}",
  "workdir_host"        : "${{myhost}}",
  "hostname"            : "${{myhost}}",
  "SLURM_SUBMIT_DIR"    : "${{SLURM_SUBMIT_DIR}}",
  "SLURM_JOB_ID"        : "${{SLURM_JOB_ID}}",
  "SLURM_JOB_NODELIST"  : "${{SLURM_JOB_NODELIST}}",
  "SLURM_SUBMIT_HOST"   : "${{SLURM_SUBMIT_HOST}}",
  "SLURM_JOB_NUM_NODES" : "${{SLURM_JOB_NUM_NODES}}",
  "SLURM_CPUS_PER_TASK" : "${{SLURM_CPUS_PER_TASK}}"
}}
EOF

# 3. Transfer to node [DO NOT CHANGE]
# ===================================

# create/empty the temporary directory on the compute-node
if [ ! -d "${{workdir}}" ]; then
  mkdir -p "${{workdir}}"
else
  rm -rf "${{workdir}}"/*
fi

# change current directory to the location of the sbatch-command
# ("submitdir" is somewhere in the home directory on the head-node)
cd "${{submitdir}}"
# copy all files/folders in "submitdir" to "workdir"
# ("workdir" == temporary directory on the compute-node)
cp -prf * ${{workdir}}
# change directory to the temporary directory on the compute-node
cd ${{workdir}}

# 4. Function to transfer back to the head-node [DO NOT CHANGE]
# =============================================================

# define clean-up function
function clean_up {{
  # - remove local files before copying
  {remove:s}
  # - change directory to the location of the sbatch-command (on the head-node)
  cd "${{submitdir}}"
  # - copy everything from the temporary directory on the compute-node
  cp -prf "${{workdir}}"/* .
  # - erase the temporary directory from the compute-node
  rm -rf "${{workdir}}"/*
  rm -rf "${{workdir}}"
  # - exit the script
  exit
}}

# call "clean_up" function when this script exits, it is run even if SLURM cancels the job
trap 'clean_up' EXIT

# 5. Execute [MODIFY COMPLETELY TO YOUR NEED]
# ===========================================

{command:s}
'''

# ---------------------------- temporary working directory on /scratch -----------------------------

scratch = '''#!/bin/bash
{slurm:s}

# 1. Generate unique directory name [DO NOT CHANGE]
# =================================================

# get my username
username=`whoami`

# get hostname
myhost=`hostname`

# get name of the temporary directory working directory in the scratch folder
# use job-id to create a unique folder
workdir="/scratch/$username/${{SLURM_JOB_ID}}"

# get submit directory
# (every file/folder below this directory is copied to the compute-node)
submitdir="${{SLURM_SUBMIT_DIR}}"

# 2. Write job-info to a log-file [MAY BE CHANDED/OMITTED]
# ========================================================

cat <<EOF > {name:s}.json
{{
  "submitdir"           : "${{submitdir}}",
  "workdir"             : "${{workdir}}",
  "workdir_host"        : "localhost",
  "hostname"            : "${{myhost}}",
  "SLURM_SUBMIT_DIR"    : "${{SLURM_SUBMIT_DIR}}",
  "SLURM_JOB_ID"        : "${{SLURM_JOB_ID}}",
  "SLURM_JOB_NODELIST"  : "${{SLURM_JOB_NODELIST}}",
  "SLURM_SUBMIT_HOST"   : "${{SLURM_SUBMIT_HOST}}",
  "SLURM_JOB_NUM_NODES" : "${{SLURM_JOB_NUM_NODES}}",
  "SLURM_CPUS_PER_TASK" : "${{SLURM_CPUS_PER_TASK}}"
}}
EOF

# 3. Transfer to node [DO NOT CHANGE]
# ===================================

# create/empty the temporary directory on the compute-node
if [ ! -d "${{workdir}}" ]; then
  mkdir -p "${{workdir}}"
else
  rm -rf "${{workdir}}"/*
fi

# change current directory to the location of the sbatch-command
# ("submitdir" is somewhere in the home directory on the head-node)
cd "${{submitdir}}"
# copy all files/folders in "submitdir" to "workdir"
# ("workdir" == temporary directory on the compute-node)
cp -prf * ${{workdir}}
# change directory to the temporary directory on the compute-node
cd ${{workdir}}

# 4. Function to transfer back to the head-node [DO NOT CHANGE]
# =============================================================

# define clean-up function
function clean_up {{
  # - remove local files before copying
  {remove:s}
  # - change directory to the location of the sbatch-command (on the head-node)
  cd "${{submitdir}}"
  # - copy everything from the temporary directory on the compute-node
  cp -prf "${{workdir}}"/* .
  # - erase the temporary directory from the compute-node
  rm -rf "${{workdir}}"/*
  rm -rf "${{workdir}}"
  # - exit the script
  exit
}}

# call "clean_up" function when this script exits, it is run even if SLURM cancels the job
trap 'clean_up' EXIT

# 5. Execute [MODIFY COMPLETELY TO YOUR NEED]
# ===========================================

{command:s}
'''

# -------------------------------------- read/write from home --------------------------------------

local = '''#!/bin/bash
{slurm:s}

# 1. Write job-info to a log-file [MAY BE CHANDED/OMITTED]
# ========================================================

# get hostname
myhost=`hostname`

# get the working directory as the current directory
workdir=`pwd`

# get submit directory
submitdir="${{SLURM_SUBMIT_DIR}}"

cat <<EOF > {name:s}.json
{{
  "submitdir"           : "${{submitdir}}",
  "workdir"             : "${{workdir}}",
  "workdir_host"        : "localhost",
  "hostname"            : "${{myhost}}",
  "SLURM_SUBMIT_DIR"    : "${{SLURM_SUBMIT_DIR}}",
  "SLURM_JOB_ID"        : "${{SLURM_JOB_ID}}",
  "SLURM_JOB_NODELIST"  : "${{SLURM_JOB_NODELIST}}",
  "SLURM_SUBMIT_HOST"   : "${{SLURM_SUBMIT_HOST}}",
  "SLURM_JOB_NUM_NODES" : "${{SLURM_JOB_NUM_NODES}}",
  "SLURM_CPUS_PER_TASK" : "${{SLURM_CPUS_PER_TASK}}"
}}
EOF

# 2. Execute [MODIFY COMPLETELY TO YOUR NEED]
# ===========================================

{command:s}

{remove:s}
'''

# ========================================= LOAD LIBRARIES =========================================

import os, sys, re, docopt

# ==================================== RAISE COMMAND LINE ERROR ====================================

def Error(msg,exit_code=1):
  print(msg)
  sys.exit(exit_code)

# ========================================== MAIN PROGRAM ==========================================

# ---------------------------------- parse command line arguments ----------------------------------

# parse command-line options
args = docopt.docopt(__doc__,version='0.0.3')

# change keys to simplify implementation:
# - remove leading "-" and "--" from options
args = {re.sub(r'([\-]{1,2})(.*)',r'\2',key): args[key] for key in args}
# - change "-" to "_" to facilitate direct use in print format
args = {key.replace('-','_'): args[key] for key in args}

# ---------------------------------------- modify arguments ----------------------------------------

# evaluate new-line characters
if   args['cmd'] and args['exec']: Error('--cmd and --exec options are exclusive')
elif args['cmd']                 : args['cmd'] = args['cmd'].replace('\\n','\n')
elif args['exec']                : args['cmd'] = open(args['exec'],'r').read()
else                             : args['cmd'] = ''

# check to ignore options
for key in ['time','mem']:
  if args[key].lower() in ['none', 'false']:
    args[key] = False

# convert human readable time format -> SLURM format
if args['time']:
  if not re.match('[0-9]*\:[0-9]*\:[0-9]*',args['time']):
    # - alias
    T = args['time']
    # - convert input to seconds
    if   T[-1] == 'd': T = float(T[:-1]) * float(60*60*24)
    elif T[-1] == 'h': T = float(T[:-1]) * float(60*60)
    elif T[-1] == 'm': T = float(T[:-1]) * float(60)
    elif T[-1] == 's': T = float(T[:-1]) * float(1)
    else             : T = float(T)
    # - convert seconds back to hours:minutes:seconds
    T = int(T)
    s = int( T % 60 );  T = ( T - s ) / 60
    m = int( T % 60 );  T = ( T - m ) / 60
    h = int( T )
    T = '%d:%02d:%02d' % (h,m,s)
    # - alias
    args['time'] = T

# combine "--rm" to command
if args['rm']: args['rm'] = 'rm -r ' + ' '.join(args['rm'])
else         : args['rm'] = ''

# ----------------------------------------- convert input ------------------------------------------

# allocate
jobnames  = []
filenames = []
paths     = []
commands  = []
options   = []

# loop over arguments
for inp in args.pop('<INPUT>'):

  # input is file -> add filename to the command
  if os.path.isfile(inp):

    jobname  = inp[2:] if inp[:2] == './' else inp
    filename = os.path.splitext(os.path.split(inp)[1])[0] + args['extension']
    path     = os.path.split(inp)[0]

    try   : command = args['cmd'] % os.path.split(inp)[1]
    except: command = args['cmd'] + os.path.split(inp)[1]

  # input is directory -> use command as is
  else:

    jobname  = inp[2:] if inp[:2] == './' else inp
    filename = args['filename'] + args['extension']
    path     = inp
    command  = args['cmd']

  # set options
  option  = [ ]
  option += [ '#SBATCH --job-name %s' % jobname ]
  option += [ '#SBATCH --out %s.out' % filename ]
  option += [ '#SBATCH --nodes 1' ]
  option += [ '#SBATCH --ntasks 1' ]
  option += [ '#SBATCH --cpus-per-task %s' % args['cpus_per_task'] ]

  if args['mem'      ]: option += [ '#SBATCH --mem %s' % args['mem'] ]
  if args['time'     ]: option += [ '#SBATCH --time %s' % args['time']]
  if args['partition']: option += [ '#SBATCH --partition %s' % args['partition']]
  if args['account'  ]: option += [ '#SBATCH --account %s' % args['account'] ]

  if args['sbatch']:
    for opt in args['sbatch']:
      option += ['#SBATCH %s' % opt]

  option  = '\n'.join(option)

  # store to list
  jobnames  += [ jobname  ]
  filenames += [ filename ]
  paths     += [ path     ]
  commands  += [ command  ]
  options   += [ option   ]

# ----------------------------------------- write scripts ------------------------------------------

for jobname, filename, path, command, option in zip(jobnames, filenames, paths, commands, options):

  if   args['type'] == 'tempdir': text = tempdir
  elif args['type'] == 'scratch': text = scratch
  elif args['type'] == 'local'  : text = local

  open(os.path.join(path,filename),'w').write(text.format(
    slurm   = option,
    name    = filename,
    command = command,
    remove  = args['rm'],
  ))

  print('Written "%s"' % os.path.join(path,filename))
